/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.nhn.pinpoint.common.dto2.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class JVMInfoThriftDTO implements org.apache.thrift.TBase<JVMInfoThriftDTO, JVMInfoThriftDTO._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("JVMInfoThriftDTO");

  private static final org.apache.thrift.protocol.TField AGENT_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("agentId", org.apache.thrift.protocol.TType.STRING, (short)1);
  private static final org.apache.thrift.protocol.TField DATA_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("dataTime", org.apache.thrift.protocol.TType.I64, (short)2);
  private static final org.apache.thrift.protocol.TField ACTIVE_THREAD_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("activeThreadCount", org.apache.thrift.protocol.TType.I32, (short)3);
  private static final org.apache.thrift.protocol.TField GC1_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("gc1Count", org.apache.thrift.protocol.TType.I64, (short)4);
  private static final org.apache.thrift.protocol.TField GC1_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("gc1Time", org.apache.thrift.protocol.TType.I64, (short)5);
  private static final org.apache.thrift.protocol.TField GC2_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("gc2Count", org.apache.thrift.protocol.TType.I64, (short)6);
  private static final org.apache.thrift.protocol.TField GC2_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("gc2Time", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField HEAP_USED_FIELD_DESC = new org.apache.thrift.protocol.TField("heapUsed", org.apache.thrift.protocol.TType.I64, (short)8);
  private static final org.apache.thrift.protocol.TField HEAP_COMMITTED_FIELD_DESC = new org.apache.thrift.protocol.TField("heapCommitted", org.apache.thrift.protocol.TType.I64, (short)9);
  private static final org.apache.thrift.protocol.TField NON_HEAP_USED_FIELD_DESC = new org.apache.thrift.protocol.TField("nonHeapUsed", org.apache.thrift.protocol.TType.I64, (short)10);
  private static final org.apache.thrift.protocol.TField NON_HEAP_COMMITTED_FIELD_DESC = new org.apache.thrift.protocol.TField("nonHeapCommitted", org.apache.thrift.protocol.TType.I64, (short)11);
  private static final org.apache.thrift.protocol.TField PROCESS_CPUTIME_FIELD_DESC = new org.apache.thrift.protocol.TField("processCPUTime", org.apache.thrift.protocol.TType.DOUBLE, (short)12);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new JVMInfoThriftDTOStandardSchemeFactory());
    schemes.put(TupleScheme.class, new JVMInfoThriftDTOTupleSchemeFactory());
  }

  private String agentId; // required
  private long dataTime; // required
  private int activeThreadCount; // required
  private long gc1Count; // optional
  private long gc1Time; // optional
  private long gc2Count; // optional
  private long gc2Time; // optional
  private long heapUsed; // required
  private long heapCommitted; // required
  private long nonHeapUsed; // required
  private long nonHeapCommitted; // required
  private double processCPUTime; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    AGENT_ID((short)1, "agentId"),
    DATA_TIME((short)2, "dataTime"),
    ACTIVE_THREAD_COUNT((short)3, "activeThreadCount"),
    GC1_COUNT((short)4, "gc1Count"),
    GC1_TIME((short)5, "gc1Time"),
    GC2_COUNT((short)6, "gc2Count"),
    GC2_TIME((short)7, "gc2Time"),
    HEAP_USED((short)8, "heapUsed"),
    HEAP_COMMITTED((short)9, "heapCommitted"),
    NON_HEAP_USED((short)10, "nonHeapUsed"),
    NON_HEAP_COMMITTED((short)11, "nonHeapCommitted"),
    PROCESS_CPUTIME((short)12, "processCPUTime");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // AGENT_ID
          return AGENT_ID;
        case 2: // DATA_TIME
          return DATA_TIME;
        case 3: // ACTIVE_THREAD_COUNT
          return ACTIVE_THREAD_COUNT;
        case 4: // GC1_COUNT
          return GC1_COUNT;
        case 5: // GC1_TIME
          return GC1_TIME;
        case 6: // GC2_COUNT
          return GC2_COUNT;
        case 7: // GC2_TIME
          return GC2_TIME;
        case 8: // HEAP_USED
          return HEAP_USED;
        case 9: // HEAP_COMMITTED
          return HEAP_COMMITTED;
        case 10: // NON_HEAP_USED
          return NON_HEAP_USED;
        case 11: // NON_HEAP_COMMITTED
          return NON_HEAP_COMMITTED;
        case 12: // PROCESS_CPUTIME
          return PROCESS_CPUTIME;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __DATATIME_ISSET_ID = 0;
  private static final int __ACTIVETHREADCOUNT_ISSET_ID = 1;
  private static final int __GC1COUNT_ISSET_ID = 2;
  private static final int __GC1TIME_ISSET_ID = 3;
  private static final int __GC2COUNT_ISSET_ID = 4;
  private static final int __GC2TIME_ISSET_ID = 5;
  private static final int __HEAPUSED_ISSET_ID = 6;
  private static final int __HEAPCOMMITTED_ISSET_ID = 7;
  private static final int __NONHEAPUSED_ISSET_ID = 8;
  private static final int __NONHEAPCOMMITTED_ISSET_ID = 9;
  private static final int __PROCESSCPUTIME_ISSET_ID = 10;
  private BitSet __isset_bit_vector = new BitSet(11);
  private _Fields optionals[] = {_Fields.GC1_COUNT,_Fields.GC1_TIME,_Fields.GC2_COUNT,_Fields.GC2_TIME,_Fields.PROCESS_CPUTIME};
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.AGENT_ID, new org.apache.thrift.meta_data.FieldMetaData("agentId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.DATA_TIME, new org.apache.thrift.meta_data.FieldMetaData("dataTime", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.ACTIVE_THREAD_COUNT, new org.apache.thrift.meta_data.FieldMetaData("activeThreadCount", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.GC1_COUNT, new org.apache.thrift.meta_data.FieldMetaData("gc1Count", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.GC1_TIME, new org.apache.thrift.meta_data.FieldMetaData("gc1Time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.GC2_COUNT, new org.apache.thrift.meta_data.FieldMetaData("gc2Count", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.GC2_TIME, new org.apache.thrift.meta_data.FieldMetaData("gc2Time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HEAP_USED, new org.apache.thrift.meta_data.FieldMetaData("heapUsed", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HEAP_COMMITTED, new org.apache.thrift.meta_data.FieldMetaData("heapCommitted", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.NON_HEAP_USED, new org.apache.thrift.meta_data.FieldMetaData("nonHeapUsed", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.NON_HEAP_COMMITTED, new org.apache.thrift.meta_data.FieldMetaData("nonHeapCommitted", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.PROCESS_CPUTIME, new org.apache.thrift.meta_data.FieldMetaData("processCPUTime", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.DOUBLE)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(JVMInfoThriftDTO.class, metaDataMap);
  }

  public JVMInfoThriftDTO() {
  }

  public JVMInfoThriftDTO(
    String agentId,
    long dataTime,
    int activeThreadCount,
    long heapUsed,
    long heapCommitted,
    long nonHeapUsed,
    long nonHeapCommitted)
  {
    this();
    this.agentId = agentId;
    this.dataTime = dataTime;
    setDataTimeIsSet(true);
    this.activeThreadCount = activeThreadCount;
    setActiveThreadCountIsSet(true);
    this.heapUsed = heapUsed;
    setHeapUsedIsSet(true);
    this.heapCommitted = heapCommitted;
    setHeapCommittedIsSet(true);
    this.nonHeapUsed = nonHeapUsed;
    setNonHeapUsedIsSet(true);
    this.nonHeapCommitted = nonHeapCommitted;
    setNonHeapCommittedIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public JVMInfoThriftDTO(JVMInfoThriftDTO other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    if (other.isSetAgentId()) {
      this.agentId = other.agentId;
    }
    this.dataTime = other.dataTime;
    this.activeThreadCount = other.activeThreadCount;
    this.gc1Count = other.gc1Count;
    this.gc1Time = other.gc1Time;
    this.gc2Count = other.gc2Count;
    this.gc2Time = other.gc2Time;
    this.heapUsed = other.heapUsed;
    this.heapCommitted = other.heapCommitted;
    this.nonHeapUsed = other.nonHeapUsed;
    this.nonHeapCommitted = other.nonHeapCommitted;
    this.processCPUTime = other.processCPUTime;
  }

  public JVMInfoThriftDTO deepCopy() {
    return new JVMInfoThriftDTO(this);
  }

  @Override
  public void clear() {
    this.agentId = null;
    setDataTimeIsSet(false);
    this.dataTime = 0;
    setActiveThreadCountIsSet(false);
    this.activeThreadCount = 0;
    setGc1CountIsSet(false);
    this.gc1Count = 0;
    setGc1TimeIsSet(false);
    this.gc1Time = 0;
    setGc2CountIsSet(false);
    this.gc2Count = 0;
    setGc2TimeIsSet(false);
    this.gc2Time = 0;
    setHeapUsedIsSet(false);
    this.heapUsed = 0;
    setHeapCommittedIsSet(false);
    this.heapCommitted = 0;
    setNonHeapUsedIsSet(false);
    this.nonHeapUsed = 0;
    setNonHeapCommittedIsSet(false);
    this.nonHeapCommitted = 0;
    setProcessCPUTimeIsSet(false);
    this.processCPUTime = 0.0;
  }

  public String getAgentId() {
    return this.agentId;
  }

  public void setAgentId(String agentId) {
    this.agentId = agentId;
  }

  public void unsetAgentId() {
    this.agentId = null;
  }

  /** Returns true if field agentId is set (has been assigned a value) and false otherwise */
  public boolean isSetAgentId() {
    return this.agentId != null;
  }

  public void setAgentIdIsSet(boolean value) {
    if (!value) {
      this.agentId = null;
    }
  }

  public long getDataTime() {
    return this.dataTime;
  }

  public void setDataTime(long dataTime) {
    this.dataTime = dataTime;
    setDataTimeIsSet(true);
  }

  public void unsetDataTime() {
    __isset_bit_vector.clear(__DATATIME_ISSET_ID);
  }

  /** Returns true if field dataTime is set (has been assigned a value) and false otherwise */
  public boolean isSetDataTime() {
    return __isset_bit_vector.get(__DATATIME_ISSET_ID);
  }

  public void setDataTimeIsSet(boolean value) {
    __isset_bit_vector.set(__DATATIME_ISSET_ID, value);
  }

  public int getActiveThreadCount() {
    return this.activeThreadCount;
  }

  public void setActiveThreadCount(int activeThreadCount) {
    this.activeThreadCount = activeThreadCount;
    setActiveThreadCountIsSet(true);
  }

  public void unsetActiveThreadCount() {
    __isset_bit_vector.clear(__ACTIVETHREADCOUNT_ISSET_ID);
  }

  /** Returns true if field activeThreadCount is set (has been assigned a value) and false otherwise */
  public boolean isSetActiveThreadCount() {
    return __isset_bit_vector.get(__ACTIVETHREADCOUNT_ISSET_ID);
  }

  public void setActiveThreadCountIsSet(boolean value) {
    __isset_bit_vector.set(__ACTIVETHREADCOUNT_ISSET_ID, value);
  }

  public long getGc1Count() {
    return this.gc1Count;
  }

  public void setGc1Count(long gc1Count) {
    this.gc1Count = gc1Count;
    setGc1CountIsSet(true);
  }

  public void unsetGc1Count() {
    __isset_bit_vector.clear(__GC1COUNT_ISSET_ID);
  }

  /** Returns true if field gc1Count is set (has been assigned a value) and false otherwise */
  public boolean isSetGc1Count() {
    return __isset_bit_vector.get(__GC1COUNT_ISSET_ID);
  }

  public void setGc1CountIsSet(boolean value) {
    __isset_bit_vector.set(__GC1COUNT_ISSET_ID, value);
  }

  public long getGc1Time() {
    return this.gc1Time;
  }

  public void setGc1Time(long gc1Time) {
    this.gc1Time = gc1Time;
    setGc1TimeIsSet(true);
  }

  public void unsetGc1Time() {
    __isset_bit_vector.clear(__GC1TIME_ISSET_ID);
  }

  /** Returns true if field gc1Time is set (has been assigned a value) and false otherwise */
  public boolean isSetGc1Time() {
    return __isset_bit_vector.get(__GC1TIME_ISSET_ID);
  }

  public void setGc1TimeIsSet(boolean value) {
    __isset_bit_vector.set(__GC1TIME_ISSET_ID, value);
  }

  public long getGc2Count() {
    return this.gc2Count;
  }

  public void setGc2Count(long gc2Count) {
    this.gc2Count = gc2Count;
    setGc2CountIsSet(true);
  }

  public void unsetGc2Count() {
    __isset_bit_vector.clear(__GC2COUNT_ISSET_ID);
  }

  /** Returns true if field gc2Count is set (has been assigned a value) and false otherwise */
  public boolean isSetGc2Count() {
    return __isset_bit_vector.get(__GC2COUNT_ISSET_ID);
  }

  public void setGc2CountIsSet(boolean value) {
    __isset_bit_vector.set(__GC2COUNT_ISSET_ID, value);
  }

  public long getGc2Time() {
    return this.gc2Time;
  }

  public void setGc2Time(long gc2Time) {
    this.gc2Time = gc2Time;
    setGc2TimeIsSet(true);
  }

  public void unsetGc2Time() {
    __isset_bit_vector.clear(__GC2TIME_ISSET_ID);
  }

  /** Returns true if field gc2Time is set (has been assigned a value) and false otherwise */
  public boolean isSetGc2Time() {
    return __isset_bit_vector.get(__GC2TIME_ISSET_ID);
  }

  public void setGc2TimeIsSet(boolean value) {
    __isset_bit_vector.set(__GC2TIME_ISSET_ID, value);
  }

  public long getHeapUsed() {
    return this.heapUsed;
  }

  public void setHeapUsed(long heapUsed) {
    this.heapUsed = heapUsed;
    setHeapUsedIsSet(true);
  }

  public void unsetHeapUsed() {
    __isset_bit_vector.clear(__HEAPUSED_ISSET_ID);
  }

  /** Returns true if field heapUsed is set (has been assigned a value) and false otherwise */
  public boolean isSetHeapUsed() {
    return __isset_bit_vector.get(__HEAPUSED_ISSET_ID);
  }

  public void setHeapUsedIsSet(boolean value) {
    __isset_bit_vector.set(__HEAPUSED_ISSET_ID, value);
  }

  public long getHeapCommitted() {
    return this.heapCommitted;
  }

  public void setHeapCommitted(long heapCommitted) {
    this.heapCommitted = heapCommitted;
    setHeapCommittedIsSet(true);
  }

  public void unsetHeapCommitted() {
    __isset_bit_vector.clear(__HEAPCOMMITTED_ISSET_ID);
  }

  /** Returns true if field heapCommitted is set (has been assigned a value) and false otherwise */
  public boolean isSetHeapCommitted() {
    return __isset_bit_vector.get(__HEAPCOMMITTED_ISSET_ID);
  }

  public void setHeapCommittedIsSet(boolean value) {
    __isset_bit_vector.set(__HEAPCOMMITTED_ISSET_ID, value);
  }

  public long getNonHeapUsed() {
    return this.nonHeapUsed;
  }

  public void setNonHeapUsed(long nonHeapUsed) {
    this.nonHeapUsed = nonHeapUsed;
    setNonHeapUsedIsSet(true);
  }

  public void unsetNonHeapUsed() {
    __isset_bit_vector.clear(__NONHEAPUSED_ISSET_ID);
  }

  /** Returns true if field nonHeapUsed is set (has been assigned a value) and false otherwise */
  public boolean isSetNonHeapUsed() {
    return __isset_bit_vector.get(__NONHEAPUSED_ISSET_ID);
  }

  public void setNonHeapUsedIsSet(boolean value) {
    __isset_bit_vector.set(__NONHEAPUSED_ISSET_ID, value);
  }

  public long getNonHeapCommitted() {
    return this.nonHeapCommitted;
  }

  public void setNonHeapCommitted(long nonHeapCommitted) {
    this.nonHeapCommitted = nonHeapCommitted;
    setNonHeapCommittedIsSet(true);
  }

  public void unsetNonHeapCommitted() {
    __isset_bit_vector.clear(__NONHEAPCOMMITTED_ISSET_ID);
  }

  /** Returns true if field nonHeapCommitted is set (has been assigned a value) and false otherwise */
  public boolean isSetNonHeapCommitted() {
    return __isset_bit_vector.get(__NONHEAPCOMMITTED_ISSET_ID);
  }

  public void setNonHeapCommittedIsSet(boolean value) {
    __isset_bit_vector.set(__NONHEAPCOMMITTED_ISSET_ID, value);
  }

  public double getProcessCPUTime() {
    return this.processCPUTime;
  }

  public void setProcessCPUTime(double processCPUTime) {
    this.processCPUTime = processCPUTime;
    setProcessCPUTimeIsSet(true);
  }

  public void unsetProcessCPUTime() {
    __isset_bit_vector.clear(__PROCESSCPUTIME_ISSET_ID);
  }

  /** Returns true if field processCPUTime is set (has been assigned a value) and false otherwise */
  public boolean isSetProcessCPUTime() {
    return __isset_bit_vector.get(__PROCESSCPUTIME_ISSET_ID);
  }

  public void setProcessCPUTimeIsSet(boolean value) {
    __isset_bit_vector.set(__PROCESSCPUTIME_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case AGENT_ID:
      if (value == null) {
        unsetAgentId();
      } else {
        setAgentId((String)value);
      }
      break;

    case DATA_TIME:
      if (value == null) {
        unsetDataTime();
      } else {
        setDataTime((Long)value);
      }
      break;

    case ACTIVE_THREAD_COUNT:
      if (value == null) {
        unsetActiveThreadCount();
      } else {
        setActiveThreadCount((Integer)value);
      }
      break;

    case GC1_COUNT:
      if (value == null) {
        unsetGc1Count();
      } else {
        setGc1Count((Long)value);
      }
      break;

    case GC1_TIME:
      if (value == null) {
        unsetGc1Time();
      } else {
        setGc1Time((Long)value);
      }
      break;

    case GC2_COUNT:
      if (value == null) {
        unsetGc2Count();
      } else {
        setGc2Count((Long)value);
      }
      break;

    case GC2_TIME:
      if (value == null) {
        unsetGc2Time();
      } else {
        setGc2Time((Long)value);
      }
      break;

    case HEAP_USED:
      if (value == null) {
        unsetHeapUsed();
      } else {
        setHeapUsed((Long)value);
      }
      break;

    case HEAP_COMMITTED:
      if (value == null) {
        unsetHeapCommitted();
      } else {
        setHeapCommitted((Long)value);
      }
      break;

    case NON_HEAP_USED:
      if (value == null) {
        unsetNonHeapUsed();
      } else {
        setNonHeapUsed((Long)value);
      }
      break;

    case NON_HEAP_COMMITTED:
      if (value == null) {
        unsetNonHeapCommitted();
      } else {
        setNonHeapCommitted((Long)value);
      }
      break;

    case PROCESS_CPUTIME:
      if (value == null) {
        unsetProcessCPUTime();
      } else {
        setProcessCPUTime((Double)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case AGENT_ID:
      return getAgentId();

    case DATA_TIME:
      return Long.valueOf(getDataTime());

    case ACTIVE_THREAD_COUNT:
      return Integer.valueOf(getActiveThreadCount());

    case GC1_COUNT:
      return Long.valueOf(getGc1Count());

    case GC1_TIME:
      return Long.valueOf(getGc1Time());

    case GC2_COUNT:
      return Long.valueOf(getGc2Count());

    case GC2_TIME:
      return Long.valueOf(getGc2Time());

    case HEAP_USED:
      return Long.valueOf(getHeapUsed());

    case HEAP_COMMITTED:
      return Long.valueOf(getHeapCommitted());

    case NON_HEAP_USED:
      return Long.valueOf(getNonHeapUsed());

    case NON_HEAP_COMMITTED:
      return Long.valueOf(getNonHeapCommitted());

    case PROCESS_CPUTIME:
      return Double.valueOf(getProcessCPUTime());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case AGENT_ID:
      return isSetAgentId();
    case DATA_TIME:
      return isSetDataTime();
    case ACTIVE_THREAD_COUNT:
      return isSetActiveThreadCount();
    case GC1_COUNT:
      return isSetGc1Count();
    case GC1_TIME:
      return isSetGc1Time();
    case GC2_COUNT:
      return isSetGc2Count();
    case GC2_TIME:
      return isSetGc2Time();
    case HEAP_USED:
      return isSetHeapUsed();
    case HEAP_COMMITTED:
      return isSetHeapCommitted();
    case NON_HEAP_USED:
      return isSetNonHeapUsed();
    case NON_HEAP_COMMITTED:
      return isSetNonHeapCommitted();
    case PROCESS_CPUTIME:
      return isSetProcessCPUTime();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof JVMInfoThriftDTO)
      return this.equals((JVMInfoThriftDTO)that);
    return false;
  }

  public boolean equals(JVMInfoThriftDTO that) {
    if (that == null)
      return false;

    boolean this_present_agentId = true && this.isSetAgentId();
    boolean that_present_agentId = true && that.isSetAgentId();
    if (this_present_agentId || that_present_agentId) {
      if (!(this_present_agentId && that_present_agentId))
        return false;
      if (!this.agentId.equals(that.agentId))
        return false;
    }

    boolean this_present_dataTime = true;
    boolean that_present_dataTime = true;
    if (this_present_dataTime || that_present_dataTime) {
      if (!(this_present_dataTime && that_present_dataTime))
        return false;
      if (this.dataTime != that.dataTime)
        return false;
    }

    boolean this_present_activeThreadCount = true;
    boolean that_present_activeThreadCount = true;
    if (this_present_activeThreadCount || that_present_activeThreadCount) {
      if (!(this_present_activeThreadCount && that_present_activeThreadCount))
        return false;
      if (this.activeThreadCount != that.activeThreadCount)
        return false;
    }

    boolean this_present_gc1Count = true && this.isSetGc1Count();
    boolean that_present_gc1Count = true && that.isSetGc1Count();
    if (this_present_gc1Count || that_present_gc1Count) {
      if (!(this_present_gc1Count && that_present_gc1Count))
        return false;
      if (this.gc1Count != that.gc1Count)
        return false;
    }

    boolean this_present_gc1Time = true && this.isSetGc1Time();
    boolean that_present_gc1Time = true && that.isSetGc1Time();
    if (this_present_gc1Time || that_present_gc1Time) {
      if (!(this_present_gc1Time && that_present_gc1Time))
        return false;
      if (this.gc1Time != that.gc1Time)
        return false;
    }

    boolean this_present_gc2Count = true && this.isSetGc2Count();
    boolean that_present_gc2Count = true && that.isSetGc2Count();
    if (this_present_gc2Count || that_present_gc2Count) {
      if (!(this_present_gc2Count && that_present_gc2Count))
        return false;
      if (this.gc2Count != that.gc2Count)
        return false;
    }

    boolean this_present_gc2Time = true && this.isSetGc2Time();
    boolean that_present_gc2Time = true && that.isSetGc2Time();
    if (this_present_gc2Time || that_present_gc2Time) {
      if (!(this_present_gc2Time && that_present_gc2Time))
        return false;
      if (this.gc2Time != that.gc2Time)
        return false;
    }

    boolean this_present_heapUsed = true;
    boolean that_present_heapUsed = true;
    if (this_present_heapUsed || that_present_heapUsed) {
      if (!(this_present_heapUsed && that_present_heapUsed))
        return false;
      if (this.heapUsed != that.heapUsed)
        return false;
    }

    boolean this_present_heapCommitted = true;
    boolean that_present_heapCommitted = true;
    if (this_present_heapCommitted || that_present_heapCommitted) {
      if (!(this_present_heapCommitted && that_present_heapCommitted))
        return false;
      if (this.heapCommitted != that.heapCommitted)
        return false;
    }

    boolean this_present_nonHeapUsed = true;
    boolean that_present_nonHeapUsed = true;
    if (this_present_nonHeapUsed || that_present_nonHeapUsed) {
      if (!(this_present_nonHeapUsed && that_present_nonHeapUsed))
        return false;
      if (this.nonHeapUsed != that.nonHeapUsed)
        return false;
    }

    boolean this_present_nonHeapCommitted = true;
    boolean that_present_nonHeapCommitted = true;
    if (this_present_nonHeapCommitted || that_present_nonHeapCommitted) {
      if (!(this_present_nonHeapCommitted && that_present_nonHeapCommitted))
        return false;
      if (this.nonHeapCommitted != that.nonHeapCommitted)
        return false;
    }

    boolean this_present_processCPUTime = true && this.isSetProcessCPUTime();
    boolean that_present_processCPUTime = true && that.isSetProcessCPUTime();
    if (this_present_processCPUTime || that_present_processCPUTime) {
      if (!(this_present_processCPUTime && that_present_processCPUTime))
        return false;
      if (this.processCPUTime != that.processCPUTime)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public int compareTo(JVMInfoThriftDTO other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    JVMInfoThriftDTO typedOther = (JVMInfoThriftDTO)other;

    lastComparison = Boolean.valueOf(isSetAgentId()).compareTo(typedOther.isSetAgentId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAgentId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.agentId, typedOther.agentId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetDataTime()).compareTo(typedOther.isSetDataTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetDataTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.dataTime, typedOther.dataTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetActiveThreadCount()).compareTo(typedOther.isSetActiveThreadCount());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetActiveThreadCount()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.activeThreadCount, typedOther.activeThreadCount);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetGc1Count()).compareTo(typedOther.isSetGc1Count());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetGc1Count()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gc1Count, typedOther.gc1Count);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetGc1Time()).compareTo(typedOther.isSetGc1Time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetGc1Time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gc1Time, typedOther.gc1Time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetGc2Count()).compareTo(typedOther.isSetGc2Count());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetGc2Count()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gc2Count, typedOther.gc2Count);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetGc2Time()).compareTo(typedOther.isSetGc2Time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetGc2Time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gc2Time, typedOther.gc2Time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHeapUsed()).compareTo(typedOther.isSetHeapUsed());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHeapUsed()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.heapUsed, typedOther.heapUsed);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHeapCommitted()).compareTo(typedOther.isSetHeapCommitted());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHeapCommitted()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.heapCommitted, typedOther.heapCommitted);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetNonHeapUsed()).compareTo(typedOther.isSetNonHeapUsed());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetNonHeapUsed()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.nonHeapUsed, typedOther.nonHeapUsed);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetNonHeapCommitted()).compareTo(typedOther.isSetNonHeapCommitted());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetNonHeapCommitted()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.nonHeapCommitted, typedOther.nonHeapCommitted);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetProcessCPUTime()).compareTo(typedOther.isSetProcessCPUTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetProcessCPUTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.processCPUTime, typedOther.processCPUTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("JVMInfoThriftDTO(");
    boolean first = true;

    sb.append("agentId:");
    if (this.agentId == null) {
      sb.append("null");
    } else {
      sb.append(this.agentId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("dataTime:");
    sb.append(this.dataTime);
    first = false;
    if (!first) sb.append(", ");
    sb.append("activeThreadCount:");
    sb.append(this.activeThreadCount);
    first = false;
    if (isSetGc1Count()) {
      if (!first) sb.append(", ");
      sb.append("gc1Count:");
      sb.append(this.gc1Count);
      first = false;
    }
    if (isSetGc1Time()) {
      if (!first) sb.append(", ");
      sb.append("gc1Time:");
      sb.append(this.gc1Time);
      first = false;
    }
    if (isSetGc2Count()) {
      if (!first) sb.append(", ");
      sb.append("gc2Count:");
      sb.append(this.gc2Count);
      first = false;
    }
    if (isSetGc2Time()) {
      if (!first) sb.append(", ");
      sb.append("gc2Time:");
      sb.append(this.gc2Time);
      first = false;
    }
    if (!first) sb.append(", ");
    sb.append("heapUsed:");
    sb.append(this.heapUsed);
    first = false;
    if (!first) sb.append(", ");
    sb.append("heapCommitted:");
    sb.append(this.heapCommitted);
    first = false;
    if (!first) sb.append(", ");
    sb.append("nonHeapUsed:");
    sb.append(this.nonHeapUsed);
    first = false;
    if (!first) sb.append(", ");
    sb.append("nonHeapCommitted:");
    sb.append(this.nonHeapCommitted);
    first = false;
    if (isSetProcessCPUTime()) {
      if (!first) sb.append(", ");
      sb.append("processCPUTime:");
      sb.append(this.processCPUTime);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bit_vector = new BitSet(1);
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class JVMInfoThriftDTOStandardSchemeFactory implements SchemeFactory {
    public JVMInfoThriftDTOStandardScheme getScheme() {
      return new JVMInfoThriftDTOStandardScheme();
    }
  }

  private static class JVMInfoThriftDTOStandardScheme extends StandardScheme<JVMInfoThriftDTO> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, JVMInfoThriftDTO struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // AGENT_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.agentId = iprot.readString();
              struct.setAgentIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // DATA_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.dataTime = iprot.readI64();
              struct.setDataTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // ACTIVE_THREAD_COUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.activeThreadCount = iprot.readI32();
              struct.setActiveThreadCountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // GC1_COUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.gc1Count = iprot.readI64();
              struct.setGc1CountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // GC1_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.gc1Time = iprot.readI64();
              struct.setGc1TimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // GC2_COUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.gc2Count = iprot.readI64();
              struct.setGc2CountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // GC2_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.gc2Time = iprot.readI64();
              struct.setGc2TimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // HEAP_USED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.heapUsed = iprot.readI64();
              struct.setHeapUsedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // HEAP_COMMITTED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.heapCommitted = iprot.readI64();
              struct.setHeapCommittedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // NON_HEAP_USED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.nonHeapUsed = iprot.readI64();
              struct.setNonHeapUsedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // NON_HEAP_COMMITTED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.nonHeapCommitted = iprot.readI64();
              struct.setNonHeapCommittedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // PROCESS_CPUTIME
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.processCPUTime = iprot.readDouble();
              struct.setProcessCPUTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, JVMInfoThriftDTO struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.agentId != null) {
        oprot.writeFieldBegin(AGENT_ID_FIELD_DESC);
        oprot.writeString(struct.agentId);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(DATA_TIME_FIELD_DESC);
      oprot.writeI64(struct.dataTime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(ACTIVE_THREAD_COUNT_FIELD_DESC);
      oprot.writeI32(struct.activeThreadCount);
      oprot.writeFieldEnd();
      if (struct.isSetGc1Count()) {
        oprot.writeFieldBegin(GC1_COUNT_FIELD_DESC);
        oprot.writeI64(struct.gc1Count);
        oprot.writeFieldEnd();
      }
      if (struct.isSetGc1Time()) {
        oprot.writeFieldBegin(GC1_TIME_FIELD_DESC);
        oprot.writeI64(struct.gc1Time);
        oprot.writeFieldEnd();
      }
      if (struct.isSetGc2Count()) {
        oprot.writeFieldBegin(GC2_COUNT_FIELD_DESC);
        oprot.writeI64(struct.gc2Count);
        oprot.writeFieldEnd();
      }
      if (struct.isSetGc2Time()) {
        oprot.writeFieldBegin(GC2_TIME_FIELD_DESC);
        oprot.writeI64(struct.gc2Time);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(HEAP_USED_FIELD_DESC);
      oprot.writeI64(struct.heapUsed);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HEAP_COMMITTED_FIELD_DESC);
      oprot.writeI64(struct.heapCommitted);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NON_HEAP_USED_FIELD_DESC);
      oprot.writeI64(struct.nonHeapUsed);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NON_HEAP_COMMITTED_FIELD_DESC);
      oprot.writeI64(struct.nonHeapCommitted);
      oprot.writeFieldEnd();
      if (struct.isSetProcessCPUTime()) {
        oprot.writeFieldBegin(PROCESS_CPUTIME_FIELD_DESC);
        oprot.writeDouble(struct.processCPUTime);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class JVMInfoThriftDTOTupleSchemeFactory implements SchemeFactory {
    public JVMInfoThriftDTOTupleScheme getScheme() {
      return new JVMInfoThriftDTOTupleScheme();
    }
  }

  private static class JVMInfoThriftDTOTupleScheme extends TupleScheme<JVMInfoThriftDTO> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, JVMInfoThriftDTO struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetAgentId()) {
        optionals.set(0);
      }
      if (struct.isSetDataTime()) {
        optionals.set(1);
      }
      if (struct.isSetActiveThreadCount()) {
        optionals.set(2);
      }
      if (struct.isSetGc1Count()) {
        optionals.set(3);
      }
      if (struct.isSetGc1Time()) {
        optionals.set(4);
      }
      if (struct.isSetGc2Count()) {
        optionals.set(5);
      }
      if (struct.isSetGc2Time()) {
        optionals.set(6);
      }
      if (struct.isSetHeapUsed()) {
        optionals.set(7);
      }
      if (struct.isSetHeapCommitted()) {
        optionals.set(8);
      }
      if (struct.isSetNonHeapUsed()) {
        optionals.set(9);
      }
      if (struct.isSetNonHeapCommitted()) {
        optionals.set(10);
      }
      if (struct.isSetProcessCPUTime()) {
        optionals.set(11);
      }
      oprot.writeBitSet(optionals, 12);
      if (struct.isSetAgentId()) {
        oprot.writeString(struct.agentId);
      }
      if (struct.isSetDataTime()) {
        oprot.writeI64(struct.dataTime);
      }
      if (struct.isSetActiveThreadCount()) {
        oprot.writeI32(struct.activeThreadCount);
      }
      if (struct.isSetGc1Count()) {
        oprot.writeI64(struct.gc1Count);
      }
      if (struct.isSetGc1Time()) {
        oprot.writeI64(struct.gc1Time);
      }
      if (struct.isSetGc2Count()) {
        oprot.writeI64(struct.gc2Count);
      }
      if (struct.isSetGc2Time()) {
        oprot.writeI64(struct.gc2Time);
      }
      if (struct.isSetHeapUsed()) {
        oprot.writeI64(struct.heapUsed);
      }
      if (struct.isSetHeapCommitted()) {
        oprot.writeI64(struct.heapCommitted);
      }
      if (struct.isSetNonHeapUsed()) {
        oprot.writeI64(struct.nonHeapUsed);
      }
      if (struct.isSetNonHeapCommitted()) {
        oprot.writeI64(struct.nonHeapCommitted);
      }
      if (struct.isSetProcessCPUTime()) {
        oprot.writeDouble(struct.processCPUTime);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, JVMInfoThriftDTO struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(12);
      if (incoming.get(0)) {
        struct.agentId = iprot.readString();
        struct.setAgentIdIsSet(true);
      }
      if (incoming.get(1)) {
        struct.dataTime = iprot.readI64();
        struct.setDataTimeIsSet(true);
      }
      if (incoming.get(2)) {
        struct.activeThreadCount = iprot.readI32();
        struct.setActiveThreadCountIsSet(true);
      }
      if (incoming.get(3)) {
        struct.gc1Count = iprot.readI64();
        struct.setGc1CountIsSet(true);
      }
      if (incoming.get(4)) {
        struct.gc1Time = iprot.readI64();
        struct.setGc1TimeIsSet(true);
      }
      if (incoming.get(5)) {
        struct.gc2Count = iprot.readI64();
        struct.setGc2CountIsSet(true);
      }
      if (incoming.get(6)) {
        struct.gc2Time = iprot.readI64();
        struct.setGc2TimeIsSet(true);
      }
      if (incoming.get(7)) {
        struct.heapUsed = iprot.readI64();
        struct.setHeapUsedIsSet(true);
      }
      if (incoming.get(8)) {
        struct.heapCommitted = iprot.readI64();
        struct.setHeapCommittedIsSet(true);
      }
      if (incoming.get(9)) {
        struct.nonHeapUsed = iprot.readI64();
        struct.setNonHeapUsedIsSet(true);
      }
      if (incoming.get(10)) {
        struct.nonHeapCommitted = iprot.readI64();
        struct.setNonHeapCommittedIsSet(true);
      }
      if (incoming.get(11)) {
        struct.processCPUTime = iprot.readDouble();
        struct.setProcessCPUTimeIsSet(true);
      }
    }
  }

}

